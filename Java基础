Integer.parseInt(string)  java将字符串转为整型
executeQuery


重载的方法，实际是完全不同的方法，只是名称相同而已!

      构成方法重载的条件：

      1.不同的含义：形参类型、形参个数、形参顺序不同

      2.只有返回值不同不构成方法的重载
	  
// 每一个源文件必须有且只有一个public class，并且类名和文件名保持一致！



Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。

栈的特点如下：

　　1. 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)

　　2. JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)

　　3. 栈属于线程私有，不能实现线程间的共享!

　　4. 栈的存储特性是“先进后出，后进先出”

　　5. 栈是由系统自动分配，速度快!栈是一个连续的内存空间!

堆的特点如下：

　　1. 堆用于存储创建好的对象和数组(数组也是对象)
　　2. JVM只有一个堆，被所有线程共享
　　3. 堆是一个不连续的内存空间，分配灵活，速度慢!

方法区(又叫静态区)特点如下：
　　1. JVM只有一个方法区，被所有线程共享!
　　2. 方法区实际也是堆，只是用于存储类、常量相关的信息!
　　3. 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等)

垃圾回收过程
　　任何一种垃圾回收算法一般要做两件基本事情：
　　1. 发现无用的对象
　　2. 回收无用对象占用的内存空间。
垃圾回收相关算法：引用可达法
垃圾回收过程：
    1、新创建的对象，绝大多数都会存储在Eden中，
    2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区
    3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。
    4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，
    5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）
     


this最常的用法：
 
　　1.  在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。
　　2. 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。
　　3. this不能用于static方法中。

java只有一个父类  默认父类object

instanceof是二元运算符，左边是对象，右边是类

数组声明后只是分配了空间，还需初始化；声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。

构造方法第一句中无super则会默认调用super

抽象类：1.含有抽象方法的类 
             2.不能实例化，只能用来被继承
             3. 抽象方法必须被子类实现
java类单继承 接口可以多继承

接口：1.常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。
         2.方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。
         3.一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。

  内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。

java Integer :缓存在{-128~127}，就是系统初始的时候，创建了一个在该范围之间的一个缓存数组
	    如果在该范围，就直接那缓存的；否则重新创建新对象

  泛型E像一个占位符一样表示“未知的某个数据类型”，我们在真正调用的时候传入这个“数据类型”

容器中所有元素的比较操作都是用equal方法

如何选用ArrayList、LinkedList、Vector?
      1. 需要线程安全时，用Vector。
      2. 不存在线程安全问题时，并且查找较多用ArrayList(一般使用它)。
      3. 不存在线程安全问题时，增加或删除元素较多用LinkedList

Barney
Java中equals和==的区别
java中的数据类型，可分为两类：
1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean
  他们之间的比较，应用双等号（==）,比较的是他们的值。
2.复合数据类型(类)
  当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。
  对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。



String 类对象代表不可变对象
StringBuilder 可变对象，效率高
因为toString方法是Object里面已经有了的方法，而所有类都是继承Object，所以“所有对象都有这个方法”。
 它通常只是为了方便输出，比如System.out.println(xx)，括号里面的“xx”如果不是String类型的话，就自动调用xx的toString()方法

collection part:
collection 两个子类 set list
	set：无顺序 不可重复
	list:   有序    可重复

Treeset 、TreeMap等实现自主排序， 要实现comparable接口
如果遇到遍历容器时，判断删除元素的情况，使用迭代器遍历!

I/O流


JVM
Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。

java到可执行的程序有一下三部：



JDK 和 JRE
JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。

UTF-8 一个中文占三个字节

I/O流的操作步骤：
  a.选择源   b.选择流   c.操作   d.释放

装饰器设计模式：
 a.抽象组件：需要装饰的抽象对象
 b.具体组件：需要装饰的对象
 c.抽象装饰类：包含了对抽象组件的引用以及装饰着共有的方法
 d.具体装饰类：被装饰的对象

Interface中的方法，在编译之后生成 class 文件时，都会自动加上 public abstract




